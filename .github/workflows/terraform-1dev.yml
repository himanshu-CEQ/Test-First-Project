name: 'Terraform-dev'

on:
  push:
    branches:
    - Feature/Bridgrecrew
    paths-ignore:
    - 'README.md'

env:
  ENV: dev
  ARM_CLIENT_ID: "${{secrets.CEQ_AZURE_SANDBOX_TF_ARM_CLIENT_ID}}"
  ARM_CLIENT_SECRET: "${{secrets.CEQ_AZURE_SANDBOX_TF_ARM_CLIENT_SECRET}}"
  ARM_SUBSCRIPTION_ID: "${{secrets.CEQ_AZURE_SANDBOX_TF_ARM_SUBS_ID}}"
  ARM_TENANT_ID: "${{secrets.CEQ_AZURE_SANDBOX_TF_ARM_TENANT_ID}}"
  TFSTATE_RG: vm-provisioning-tfstate
  TFSTATE_STORAGE_ACCOUNT: vmprovisiontfstate
  TFSTATE_CONTAINER: tfstate
  APP_ID: APID00002

jobs:
  

  terraScan:
    name: 'terraScan'
    runs-on: ubuntu-latest

    defaults:
      run:
        shell: bash

    steps:
    - name: Checkout
      uses: actions/checkout@v1
      
    - name: Terraform Scan Install
      run: curl --location https://github.com/accurics/terrascan/releases/download/v1.9.0/terrascan_1.9.0_Linux_x86_64.tar.gz --output terrascan.tar.gz && tar -xf terrascan.tar.gz terrascan && rm terrascan.tar.gz && install terrascan /usr/local/bin && rm terrascan && terrascan
    
      
    - name:  TerraScan Scan
      run: terrascan scan -t azure
      continue-on-error: true
      
  Scan_with_BridgeCrew:
    # The type of runner that the job will run on
    name: 'bridgecrew_scan'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Run Bridgecrew 
      id: Bridgecrew
      uses: bridgecrewio/bridgecrew-action@master
      with:
        api-key: ${{ secrets.API_KEY }}
        soft_fail: true
      env:  
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_REF: ${{ github.ref }}
        GITHUB_SHA: ${{ github.sha }}
        GITHUB_SERVER_URL: $GITHUB_SERVER_URL  
    - name: Expose report
      uses: actions/upload-artifact@v2
      with:
        name: SARIF results
        path: results.sarif
    # Uploads results.sarif to GitHub repository using the upload-sarif action
  #  - uses: github/codeql-action/upload-sarif@v1
     # with:
        # Path to SARIF file relative to the root of the repository
    #    sarif_file: results.sarif
  terraform:
    needs: [terraScan,Scan_with_BridgeCrew]
    name: 'Terraform'
    runs-on: ubuntu-latest
   
    env:
      ARM_CLIENT_ID: "${{secrets.CEQ_AZURE_SANDBOX_TF_ARM_CLIENT_ID}}"
      ARM_CLIENT_SECRET: "${{secrets.CEQ_AZURE_SANDBOX_TF_ARM_CLIENT_SECRET}}"
      ARM_SUBSCRIPTION_ID: "${{secrets.CEQ_AZURE_SANDBOX_TF_ARM_SUBS_ID}}"
      ARM_TENANT_ID: "${{secrets.CEQ_AZURE_SANDBOX_TF_ARM_TENANT_ID}}"
    defaults:
      run:
        shell: bash

    steps:
    - name: Login to azure
      uses: azure/login@v1
      with:
        creds: ${{secrets.CEQ_AZURE_GITHUB_SANDBOX_SPN_KEY_ID}} 
        enable-AzPSSession: true

    - name: Checkout
      uses: actions/checkout@v1
      
    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v1
      with:
        terraform_version: 0.15.1
        cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
        
    - name: Setup git global config
      run:  git config --global url."https://oauth2:${{secrets.PAT_TOKEN}}@github.com".insteadOf https://github.com

      
    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      run: terraform init -reconfigure -force-copy -backend-config="resource_group_name=$TFSTATE_RG" -backend-config="storage_account_name=$TFSTATE_STORAGE_ACCOUNT" -backend-config="container_name=$TFSTATE_CONTAINER" -backend-config="key=$ENV-$APP_ID.tfstate" -input=false
      

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      run: terraform plan -var-file="$ENV/terraform.tfvars" -input=false
    

#   terraformApply: 
#     name: 'Terraform_Apply'
#     runs-on: ubuntu-latest
#     needs: ["terraform"]
      
#     environment:
#       name: terraform_apply

#     defaults:
#      run:
#       shell: bash

#     steps:
#       - name: Login to azure
#         uses: azure/login@v1
#         with:
#            creds: ${{secrets.CEQ_AZURE_GITHUB_SANDBOX_SPN_KEY_ID}} 
#            enable-AzPSSession: true

#       - name: Checkout
#         uses: actions/checkout@v2
      
#       # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
#       - name: Setup Terraform
#         uses: hashicorp/setup-terraform@v1
#         with:
#           terraform_version: 0.15.1
#           terraform_wrapper: false

#       - name: Setup git global config
#         run:  git config --global url."https://oauth2:${{secrets.PAT_TOKEN}}@github.com".insteadOf https://github.com

#       # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
#       - name: Terraform Init
#         run: terraform init -reconfigure -force-copy -backend-config="resource_group_name=$TFSTATE_RG" -backend-config="storage_account_name=$TFSTATE_STORAGE_ACCOUNT" -backend-config="container_name=$TFSTATE_CONTAINER" -backend-config="key=$ENV-$APP_ID.tfstate" -input=false

#       # Generates an execution plan for Terraform
# #       - name: Terraform Plan
# #         run: cd ./vm-selfserviceprovisioning-windows/main_modules && terraform plan -var-file="../../$ENV/terraform.tfvars" -input=false

#       - name: Terraform Apply 
#         run: terraform apply -auto-approve -var-file="$ENV/terraform.tfvars" -input=false


#       - name: Terraform Output 
#         run: vm=$(terraform output) && echo $vm > terraform-output1.ps1

#       - name: Terraform Output -PS File Artifact Upload
#         uses: actions/upload-artifact@v2
#         with:
#           name: output
#           path: ./terraform-output1.ps1
        
#       - name: Terraform Output -PS File Artifact download
#         uses: actions/download-artifact@v2
#         with:
#           name: output

#       - name: Convert Terraform Output To CSV
#         shell: pwsh
#         run: |
#           [string]$str = get-Content terraform-output1.ps1
#           $last=$str.length-8
#           $str1=$str.Substring(7,$last)
#           $str2=$str1.replace("=","")
#           $str3=$str2.replace("  "," ")
#           $str4=$str3.trim()
#           $str5=$str4.replace('"','')
#           $str0=$str5.replace("}","")
#           $str6=$str0.trim()
#           $str7=$Str6.split(" ")
#           $lnt = $null
#           $Hash = @{}
#           $lnt= $str7.length/2
#           for ($i=0; $i -lt $lnt; $i++) {
#             $Hash.Add($str7[2*$i],$str7[2*$i+1])
#           }
#           $Hash.GetEnumerator() | Select-Object -Property key, value | Export-Csv -NoTypeInformation -Path .\newvmlistold.csv
#           Get-Content -Path .\newvmlistold.csv | Select-Object -Skip 1 | Add-Content -Path .\newvmlist.csv 

#       - name: Terraform Output -CSV File Artifact Upload
#         uses: actions/upload-artifact@v2
#         with:
#           name: csv_file
#           path: newvmlist.csv

#       - name: Download Azure Dependencies Modules
#         uses: azure/powershell@v1
#         with:
#           inlineScript: | 
#                 Install-Module -Name Az.Compute -Force -AllowClobber
#                 Install-Module -Name Az.Storage -Force -AllowClobber
#           azPSVersion: '5.0.0'


#       - name: Run Azure PowerShell -CSV File Download
#         uses: azure/powershell@v1
#         with:
#           inlineScript: |
#             . .\${{env.ENV}}\Post-Provisioning-variables.ps1
#             $date=(get-date).AddMinutes(10).ToString("HH:mm");
#             $storage_account = New-AzStorageContext -StorageAccountName "$sentinal_storageaccount" -UseConnectedAccount;
#             try {
#               Get-AzStorageBlobContent -Container $pp_container -Blob ${{env.ENV}}-${{env.APP_ID}}.csv -Context $storage_account 
#             }
#             catch {
#             write-host "***********Find Not found. Creatig New file in next step************"
#             }
#           azPSVersion: '5.0.0'
#         continue-on-error: true 

#       - name: Download terraform Output -CSV Artifact
#         uses: actions/download-artifact@v2
#         with:
#           name: csv_file
#       - name: Compare Both Files
#         shell: pwsh
#         run: |
#           #Import both files
#           try {
#               Write-Output "try"
#               $vms = Import-Csv -Path ./${{env.ENV}}-${{env.APP_ID}}.csv -Header 'vm', 'rg'
#               # File 1 will retain information for Vmson which Post provisioning done
#               $vm_check = Import-Csv -Path "./newvmlist.csv" -Header 'vm', 'rg' 
#               # File 2 will retain information ablut runtime generated VM and RG list
#               # $file2 | Format-Table
#               $dict = New-Object System.Collections.Generic.Dictionary"[String,String]"
#               $newstoragelist = New-Object System.Collections.Generic.Dictionary"[String,String]"
#               # Loop through the file
#               foreach ($vm_chk in $vm_check)
#               {
#                   if ($vms | Where-Object {$_.vm -eq $vm_chk.vm -and $_.rg -eq $vm_chk.rg})
#                   {
#                       Write-Output "Vm, rg exist" $vm_chk.vm , $vm_chk.rg
#                       $newstoragelist.Add($vm_chk.vm, $vm_chk.rg)
#                   }
#                   else
#                   {
#                       Write-Output "Vm, rg not exist" $vm_chk.vm , $vm_chk.rg
#                       $dict.Add($vm_chk.vm, $vm_chk.rg) 
#                       $newstoragelist.Add($vm_chk.vm, $vm_chk.rg)
#                   }
#               }
#               Write-Output $dict > hash.ps1
#               $newstoragelist.GetEnumerator() | Select-Object -Property key, value | Export-Csv -Path .\newvmlist3.csv
#               Get-Content -Path .\newvmlist3.csv | Select-Object -Skip 1 | Add-Content -Path .\${{env.ENV}}-${{env.APP_ID}}.csv
#           }
#           catch {
#                 Write-Output "catch"
#                 new-item ./${{env.ENV}}-${{env.APP_ID}}.csv
#                 $vms = Import-Csv -Path ./${{env.ENV}}-${{env.APP_ID}}.csv -Header 'vm', 'rg'
#                 $vm_check = Import-Csv -Path "./newvmlist.csv" -Header 'vm', 'rg' 
#                 # File 2 will retain information ablut runtime generated VM and RG list
#                 # $file2 | Format-Table
#                 $dict = New-Object System.Collections.Generic.Dictionary"[String,String]"
#                 $newstoragelist = New-Object System.Collections.Generic.Dictionary"[String,String]"
#                 # Loop through the file
#                 foreach ($vm_chk in $vm_check)
#                 {
#                     if ($vms | Where-Object {$_.vm -eq $vm_chk.vm -and $_.rg -eq $vm_chk.rg})
#                     {
#                         Write-Output "Vm, rg exist" $vm_chk.vm , $vm_chk.rg
#                         $newstoragelist.Add($vm_chk.vm, $vm_chk.rg)
#                     }
#                     else
#                     {
#                         Write-Output "Vm, rg not exist" $vm_chk.vm , $vm_chk.rg
#                         $dict.Add($vm_chk.vm, $vm_chk.rg) 
#                         $newstoragelist.Add($vm_chk.vm, $vm_chk.rg)
#                     }
#                 }
#                 Write-Output $dict > hash.ps1
#                 $newstoragelist.GetEnumerator() | Select-Object -Property key, value | Export-Csv -Path .\newvmlist3.csv
#                 Get-Content -Path .\newvmlist3.csv | Select-Object -Skip 1 | Add-Content -Path .\${{env.ENV}}-${{env.APP_ID}}.csv 
#           }
#       - name: Terraform Output -CSV File Artifact Upload
#         uses: actions/upload-artifact@v2
#         with:
#           name: finalHash_file
#           path: hash.ps1

#       - name: Download terraform Output -Artifact FinalHash
#         uses: actions/download-artifact@v2
#         with:
#           name: finalHash_file
            
#       - name: Run Azure PowerShell to Upgrade PS -multiple VMS
#         uses: azure/powershell@v1
#         with:
#           inlineScript: |
#               $vm_name = Get-Content hash.ps1
#               $lastcount=$vm_name.count-1
#               $target=@{}
#               for ($i=3; $i -lt $lastcount; $i++) {
#                   $vm_name1= $null
#                   $vm_name1=$vm_name[$i].split(" ")
#                   $target.Add($vm_name1[0],$vm_name1[$vm_name1.count-1])
                  
#               }
#               $target.GetEnumerator() | ForEach-Object{
#                 Restart-AzVM -ResourceGroupName $_.value -Name $_.key
#                 start-sleep -s 30
#                 $azParmsUpgradePs= @{
#                 ResourceGroupName = $_.value
#                 VMName = $_.key
#                 CommandId = "RunPowerShellScript"
#                 ScriptPath = "./provisioning/PsUpgrade.ps1"
#                 }
#                 Invoke-AzVMRunCommand @azParmsUpgradePs 
#                 Restart-AzVM -ResourceGroupName $_.value -Name $_.key
#                 start-sleep -s 30
#                 }
#           azPSVersion: '5.0.0'

          
#       # - name: Sleep for 30 seconds
#       #   run: Start-Sleep -s 30
#       #   shell: pwsh


#       - name: Run Azure PowerShell to renaming CD Drive -multiple VMS
#         uses: azure/powershell@v1
#         with:
#           inlineScript: |
#               . .\${{env.ENV}}\Post-Provisioning-variables.ps1
#               $vm_name = Get-Content hash.ps1
#               $lastcount=$vm_name.count-1
#               $target=@{}
#               for ($i=3; $i -lt $lastcount; $i++) {
#                   $vm_name1= $null
#                   $vm_name1=$vm_name[$i].split(" ")
#                   $target.Add($vm_name1[0],$vm_name1[$vm_name1.count-1])
#               }
#               $target.GetEnumerator() | ForEach-Object{
#               $azParmsRemapcddriveletter = @{
#               ResourceGroupName = $_.value
#               VMName = $_.key
#               CommandId = "RunPowerShellScript"
#               ScriptPath = "./provisioning/Remap_cd_drive_letter.ps1"
#               }
#               Invoke-AzVMRunCommand @azParmsRemapcddriveletter 
#               }
#           azPSVersion: '5.0.0'
#         continue-on-error: true

#       # - name: Sleep for 30 seconds
#       #   run: Start-Sleep -s 30
#       #   shell: pwsh

#       - name: Run Azure PowerShell WSUS Config -multiple VMS
#         uses: azure/powershell@v1
#         with:
#           inlineScript: |
#             . .\${{env.ENV}}\Post-Provisioning-variables.ps1
#             Write-Host $target_group
#             $vm_name = Get-Content hash.ps1
#             $lastcount=$vm_name.count-1
#             $target=@{}
#             for ($i=3; $i -lt $lastcount; $i++) {
#                 $vm_name1= $null
#                 $vm_name1=$vm_name[$i].split(" ")
#                 $target.Add($vm_name1[0],$vm_name1[$vm_name1.count-1])
#             }
#             $target.GetEnumerator() | ForEach-Object{
#             $azParmsWSUSConfig = @{
#               ResourceGroupName = $_.value
#               VMName = $_.key
#               CommandId = "RunPowerShellScript"
#               ScriptPath = "./provisioning/WSUSConfig.ps1"
#             }
#             Invoke-AzVMRunCommand @azParmsWSUSConfig -Parameter @{target_group = "$target_group" ; wu_server ="$wu_server";  wu_status_server = "$wu_status_server"}
#             }
#           azPSVersion: '5.0.0'
#         continue-on-error: true
        
#       # - name: Sleep for 30 seconds
#       #   run: Start-Sleep -s 30
#       #   shell: pwsh

#   #     - name: Run Azure PowerShell Mcafee Install
#   #       uses: azure/powershell@v1
#   #       with:
#   #         inlineScript: |
#   #           . .\${{env.ENV}}\Post-Provisioning-variables.ps1
#   #           Install-Module -Name Az.Compute -Force -AllowClobber
#   #           Install-Module -Name Az.Storage -Force -AllowClobber
#   #           $vm_name = Get-Content hash.ps1
#   #           $lastcount=$vm_name.count-1
#   #           $target=@{}
#   #           for ($i=3; $i -lt $lastcount; $i++) {
#   #               $vm_name1= $null
#   #               $vm_name1=$vm_name[$i].split(" ")
#   #               if ($vm_name1[0] -ne "key") {
#   #                   $target.Add($vm_name1[0],$vm_name1[$vm_name1.count-1])
#   #               }
#   #           }
#   #           $target.GetEnumerator() | ForEach-Object{
#   #           $azParmsmacfee = @{
#   #             ResourceGroupName = $_.value
#   #             VMName = $_.Key
#   #             CommandId = "RunPowerShellScript"
#   #             ScriptPath = "./provisioning/macfee.ps1"
#   #           }
#   #           $date=(get-date).AddMinutes(10).ToString("HH:mm");
#   #           $storage_account = New-AzStorageContext -StorageAccountName "$storageaccount" -UseConnectedAccount;
#   #           $account_sas = New-AzStorageContainerSASToken -Context $storage_account -Name "$container_name" -Permission r -ExpiryTime $date;
#   #           $script = get-content "./provisioning/macfee.ps1" -raw
#   #           'param($storageaccount,$storagecontainer,$storageblobname)'+"`n "+"$"+"sas_token=" + "`"" +"$account_sas" + "`""  +"`n$script" |Out-File "./provisioning/macfee.ps1"
#   #           Invoke-AzVMRunCommand @azParmsmacfee -Parameter @{storagecontainer = "$container_name"; storageblobname = "$storageblobname"; storageaccount = "$storageaccount"};
#   #           remove-item "./provisioning/macfee.ps1"
#   #           }
#   #         azPSVersion: '5.0.0'
#   #       continue-on-error: true

#       - name: Run Azure PowerShell Sentinal Install -multiple VMS
#         uses: azure/powershell@v1
#         with:
#           inlineScript: |
#             . .\${{env.ENV}}\Post-Provisioning-variables.ps1
#             $date=(get-date).AddMinutes(60).ToString("HH:mm");
#             $storage_account = New-AzStorageContext -StorageAccountName "$sentinal_storageaccount" -UseConnectedAccount;
#             $account_sas = New-AzStorageContainerSASToken -Context $storage_account  -Name "$sentinal_container_name" -Permission r -ExpiryTime $date;
#             $script = get-content "./provisioning/SentinelInstall.ps1" -raw
#             'param($storageaccount,$storagecontainer,$storageblobname,$sentinal_token)'+"`n "+"$"+"sas_token=" + "`"" +"$account_sas" + "`""  +"`n$script" |Out-File "./provisioning/SentinelInstall.ps1"
#             $vm_name = Get-Content hash.ps1
#             $lastcount=$vm_name.count-1
#             $target=@{}
#             for ($i=3; $i -lt $lastcount; $i++) {
#                 $vm_name1= $null
#                 $vm_name1=$vm_name[$i].split(" ")
#                 $target.Add($vm_name1[0],$vm_name1[$vm_name1.count-1])
#             }
#             $target.GetEnumerator() | ForEach-Object{
#             $azParmsSentinelInstall = @{
#               ResourceGroupName = $_.Value
#               VMName = $_.Key
#               CommandId = "RunPowerShellScript"
#               ScriptPath = "./provisioning/SentinelInstall.ps1"
#             }
#             Invoke-AzVMRunCommand @azParmsSentinelInstall -Parameter @{storageblobname = "$sentinal_storageblobname"; storageaccount = "$sentinal_storageaccount";storagecontainer="$sentinal_container_name"; sentinal_token = "${{secrets.SENTINEL_TOKEN}}"};
#             }
#           azPSVersion: '5.0.0'
#         continue-on-error: true

#       # - name: Sleep for 30 seconds
#       #   run: Start-Sleep -s 30
#       #   shell: pwsh
#   # #     - name: Run Azure PowerShell Add Local Admin to AD
#   # #       uses: azure/powershell@v1
#   # #       with:
#   # #         inlineScript: |
#   # #           . .\${{env.ENV}}\Post-Provisioning-variables.ps1
#   # #           Install-Module -Name Az.Compute -Force -AllowClobber
#   # #           $azParmsADSecurity = @{
#   # #             ResourceGroupName = "$vm_ad_resourcegroupname"
#   # #             VMName = "$ad_vm_name"
#   # #             CommandId = "RunPowerShellScript"
#   # #             ScriptPath = "./provisioning/ADSecurityGroupandLocalAdmin.ps1"
#   # #           }
#   # #           $vm_name_admin=$vm_name + "_admin"
#   # #           Invoke-AzVMRunCommand @azParmsADSecurity -Parameter @{groupname="$vm_name_admins";ou="$ad_ou";ad_manager="$ad_vm_user";domain="$vm_tags_DomainSuffix"; ad_groups="$ad_groups"; db_groups ="$db_groups"; vm_name="$vm_name"}
#   # #         azPSVersion: '5.0.0'
#   # #       continue-on-error: true

#   # #     - name: Run Azure PowerShell Add AD GP to Local
#   # #       uses: azure/powershell@v1
#   # #       with:
#   # #         inlineScript: |
#   # #           . .\${{env.ENV}}\Post-Provisioning-variables.ps1
#   # #           Install-Module -Name Az.Compute -Force -AllowClobber
#   # #           $azParmsAddGroupToLocalAdmin = @{
#   # #             ResourceGroupName = "$vm_ad_resourcegroupname"
#   # #             VMName = "$ad_vm_name"
#   # #             CommandId = "RunPowerShellScript"
#   # #             ScriptPath = "./provisioning/AddGroupToLocalAdmin.ps1"
#   # #           }
#   # #           Invoke-AzVMRunCommand @azParmsAddGroupToLocalAdmin  -Parameter @{groupname="$vm_name_admins";  ad_groups="$ad_groups";}
#   # #         azPSVersion: '5.0.0'
#   # #       continue-on-error: true
          
#       - name: Run Azure PowerShell Format Disk -multiple VMS
#         uses: azure/powershell@v1
#         with:
#           inlineScript: |
#             . .\${{env.ENV}}\Post-Provisioning-variables.ps1
#             $vm_name = Get-Content hash.ps1
#             $lastcount=$vm_name.count-1
#             $target=@{}
#             for ($i=3; $i -lt $lastcount; $i++) {
#                 $vm_name1= $null
#                 $vm_name1=$vm_name[$i].split(" ")
#                 $target.Add($vm_name1[0],$vm_name1[$vm_name1.count-1])
#             }
#             $target.GetEnumerator() | ForEach-Object{
#             $azParmsDiskSetup = @{
#               ResourceGroupName = $_.Value
#               VMName = $_.Key
#               CommandId = "RunPowerShellScript"
#               ScriptPath = "./provisioning/DiskSetup.ps1"
#             }
#             Invoke-AzVMRunCommand @azParmsDiskSetup  -Parameter @{driveformat="$driveformat"}
#             }
#           azPSVersion: '5.0.0'
#         continue-on-error: true
      
#       # - name: Sleep for 30 seconds
#       #   run: Start-Sleep -s 30
#       #   shell: pwsh
        
#       - name: Run Azure PowerShell Configure Commvault -multiple VMS
#         uses: azure/powershell@v1
#         with:
#           inlineScript: |
#             . .\${{env.ENV}}\Post-Provisioning-variables.ps1
#             $date=(get-date).AddMinutes(60).ToString("HH:mm")
#             $storage_account = New-AzStorageContext -StorageAccountName "$commvault_storageaccount" -UseConnectedAccount
#             $account_sas = New-AzStorageContainerSASToken -Context $storage_account  -Name "$commvault_container_name"  -Permission r  -ExpiryTime $date 
#             $script = get-content "./provisioning/ConfigureCommvault.ps1" -raw
#             'param($commvault_servicepack_blob,$vcplusinstaller,$storagecontainer,$storageaccount)'+"`n "+"$"+"sas_token=" + "`"" +"$account_sas" + "`""  +"`n$script" |Out-File "./provisioning/ConfigureCommvault.ps1"
#             $vm_name = Get-Content hash.ps1
#             $lastcount=$vm_name.count-1
#             $target=@{}
#             for ($i=3; $i -lt $lastcount; $i++) {
#                 $vm_name1= $null
#                 $vm_name1=$vm_name[$i].split(" ")
#                 $target.Add($vm_name1[0],$vm_name1[$vm_name1.count-1])
#             }
#             $target.GetEnumerator() | ForEach-Object{
#             $azParmsConfigureCommvault = @{
#               ResourceGroupName = $_.Value
#               VMName = $_.Key
#               CommandId = "RunPowerShellScript"
#               ScriptPath = "./provisioning/ConfigureCommvault.ps1"
#             }
#             Invoke-AzVMRunCommand @azParmsConfigureCommvault -Parameter @{storagecontainer="$commvault_container_name";storageaccount="$commvault_storageaccount";vcplusinstaller="$vcplusinstaller";commvault_servicepack_blob="$commvault_servicepack_blob";}
#             }
#           azPSVersion: '5.0.0'  
#         continue-on-error: true
          
#       # - name: Sleep for 30 seconds
#       #   run: Start-Sleep -s 30
#       #   shell: pwsh

#       - name: Run Azure PowerShell Upload -final CSV FIle
#         uses: azure/powershell@v1
#         with:
#           inlineScript: |
#             . .\${{env.ENV}}\Post-Provisioning-variables.ps1
#             $date=(get-date).AddMinutes(10).ToString("HH:mm");
#             $storage_account = New-AzStorageContext -StorageAccountName "$sentinal_storageaccount" -UseConnectedAccount;
#             Set-AzStorageBlobContent -File .\${{env.ENV}}-${{env.APP_ID}}.csv  -Container $pp_container -Context $storage_account -force
#           azPSVersion: '5.0.0'
#         continue-on-error: true 
© 2021 GitHub, Inc.
Terms
Privacy
Security
Status
Docs
Contact GitHub
Pricing
API
Training
Blog
About

